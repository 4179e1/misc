//
// Simple request-reply broker
//
#include "zhelpers.h"

int main (void)
{
	// Prepare our context and sockets
	void *context = zmq_init (1);
	void *frontend = zmq_socket (context, ZMQ_ROUTER);
	void *backend = zmq_socket (context, ZMQ_DEALER);
	zmq_bind (frontend, "tcp://*:5559");
	zmq_bind (backend, "tcp://*:5560");

	// Initialize poll set
	zmq_pollitem_t items[] = 
	{
		{frontend, 0, ZMQ_POLLIN, 0},
		{backend, 0, ZMQ_POLLIN, 0}
	};

	// Switch messages between sockets
	while (1)
	{
		zmq_msg_t message;
		int64_t more;		// Multipart detection

		zmq_poll (items, 2, -1);
		if (items [0].revents & ZMQ_POLLIN)
		{
			while (1)
			{
				// Process all parts of the message
				zmq_msg_init (&message);
				zmq_recv (frontend, &message, 0);
				size_t more_size = sizeof (more);
				zmq_getsockopt (frontend, ZMQ_RCVMORE, &more, &more_size);
				zmq_send (backend, &message, more ? ZMQ_SNDMORE : 0);
				zmq_msg_close (&message);
				if (!more)
					break;
			}
		}
		if (items [1]. revents & ZMQ_POLLIN)
		{
			while (1)
			{
				// Process all parts of the message
				zmq_msg_init (&message);
				zmq_recv (backend, &message, 0);
				size_t more_size = sizeof (more);
				zmq_getsockopt (backend, ZMQ_RCVMORE, &more, &more_size);
				zmq_send (frontend, &message, more? ZMQ_SNDMORE : 0);
				zmq_msg_close (&message);
				if (!more)
					break; // Last message part
			}
		}
	}
	zmq_close (frontend);
	zmq_close (backend);
	zmq_close (context);
	return 0;
}
